# GOF23种设计模式学习笔记
* 创建型(creation)
    1. **单例模式**(singleton)
        ```
            单例模式就是让要使用的类仅拥有一个实例化对象
        ```
    2. 工厂模式(factory)
         1. **简单工厂**(simpleFactory)
            ```
                简单工厂在工作中最常用，但并不符合设计模式的开闭原则
            ```
         2. 工厂方法(factoryMethod)
            ```
                工厂方法模式符合开闭原则，但是增加了类的数量，增加了复杂度
            ```
         3. 抽象工厂(abstractFactory)
            ```
                抽象工厂模式常用于大型项目，用于构造产品族，通常与建造者模式配合使用
            ```
    3. 建造者模式(builder)
          ```
            建造者模式常用于组合抽象工厂产出的零件，一般通过调用装饰器来调用建造者
          ```
    4. **原型模式**(prototype)
        ```
            原型模式也叫克隆模式，用于克隆常用的对象，通过类实现Cloneable接口，重写clone()方法避免多次new的过程，节省创建对象的时间
        ```
* 结构型(Structural)
    1. 适配器模式(adapter)
    ```
        当某一对象调用的方法内部注入接口的实现类发生改变时，需要开发相应的适配器用于调整，此模式大多用于旧系统的升级
    ```
    2. **代理模式**(proxy)
    ```
        定义一个公共接口，分别用代理类和主要实现类实现这个接口，可以通过对代理对象的访问调用主要实现类的方法，用于控制外部对实际实现类的访问，多用于各种开源框架内部，此模式的实现方式一般有静态实现和动态实现两种，多使用动态方式实现
    ```
    3. 桥接模式(bridge)
    ```
        当两种类型耦合时，如果使用继承，则会使类的数量急剧增加，此时，可以通过桥接模式将不同类型分成两个维度，再将其中一个维度注入另一个维度，实现两种类型的结合，模式将类的复杂度由n*m变为n+m。此模式大多用于某些框架架构、日志系统等地。
    ```
    4. **组合模式**(composite)
    ```
        此模式在处理树形结构时十分常用，定义统一接口处理叶子实现类和容器实现类（包含了叶子实现类的处理），常运用于文件系统管理和层次文件解析
    ```
    5. **装饰模式**(decorator)
    ```
        此模式的作用主要是动态地为一个对象添加功能，此模式主要有一个统一接口，然后让一个超级类实现此接口，再让具体装饰类继承超级类，在具体装饰类中可重写接口中的方法并且导入新的装饰方法，I/O流中的输入输出流便使用了此模式
    ```
    6. **外观模式**(facade)
    ```
        此模式的思想是封装子系统的调用逻辑，使外部调用内部接口时可以忽略大多数实现逻辑，各种框架中常用
    ```
    7. 享元模式(flyweight)
    ```
        此模式主要是处理拥有大量共同特征（内部状态），只有少部分不同特征（外部状态）的对象的内存占用问题的，可以节省大量内存，享元模式常与工厂模式配合使用
    ```
    
* 行为型(Behavioral)
    1. 责任链模式(chain of responsibility)
       ```
           
       ```
    
[设计模式关系图](src/images/设计模式关系图.jpg)